<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://906571331.github.io/yx.github.io/</id>
    <title>WuXin</title>
    <updated>2020-05-06T14:54:46.214Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://906571331.github.io/yx.github.io/"/>
    <link rel="self" href="https://906571331.github.io/yx.github.io/atom.xml"/>
    <subtitle>成千上万个门口，总有一个人要先走。</subtitle>
    <logo>https://906571331.github.io/yx.github.io/images/avatar.png</logo>
    <icon>https://906571331.github.io/yx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WuXin</rights>
    <entry>
        <title type="html"><![CDATA[阿里云服务器下jupyter notebook 安装、远程访问以及处理错误]]></title>
        <id>https://906571331.github.io/yx.github.io/post/4dpJZ8owu/</id>
        <link href="https://906571331.github.io/yx.github.io/post/4dpJZ8owu/">
        </link>
        <updated>2020-05-06T14:51:49.000Z</updated>
        <content type="html"><![CDATA[<h4 id="一安装所需的环境">一.安装所需的环境</h4>
<pre><code class="language-python">1.	在虚拟环境中安装jupyter
(jiqistudy)&gt; pip install jupyter -i  https://pypi.tuna.tsinghua.edu.cn/simple/
2.	安装所需的python库
(jiqistudy)&gt; pip install numpy -i  https://pypi.tuna.tsinghua.edu.cn/simple/
(jiqistudy)&gt; pip install matplotlib -i https://pypi.tuna.tsinghua.edu.cn/simple/
(jiqistudy)&gt; pip install pandas -i  https://pypi.tuna.tsinghua.edu.cn/simple/
(jiqistudy)&gt; pip install sklearn -i  https://pypi.tuna.tsinghua.edu.cn/simple/
3.	创建目标目录并进入
(jiqistudy)&gt; mkdir algorithm
(jiqistudy)&gt; cd algorithm
4.	启动jupyter notebook
(jiqistudy)&gt; jupyter notebook
</code></pre>
<h4 id="二-jupyter远程访问配置">二、jupyter远程访问配置</h4>
<p>1、生成配置文件（~/.jupyter/jupyter_notebook_config.py）</p>
<pre><code class="language-python">jupyter notebook --generate-config
</code></pre>
<p>2、生成密钥</p>
<pre><code class="language-python">jupyter notebook password  # 自己造一个密码输入一确认一次
vim ~/.jupyter/jupyter_notebook_config.json
</code></pre>
<p>记下密钥，sha1:...<br>
3、编辑配置文件</p>
<pre><code class="language-python">vim ~/.jupyter/jupyter_notebook_config.py
</code></pre>
<p>修改以下几项：</p>
<pre><code class="language-python">c.NotebookApp.ip='*'                                  # 就是设置所有ip皆可访问  
c.NotebookApp.password = u'sha1:03...       # 刚才复制的那个密文'  
c.NotebookApp.open_browser = False       # 禁止自动打开浏览器  
c.NotebookApp.port =1234                         #随便指定一个端口  
</code></pre>
<p>设置端口后要在阿里云控制台把这个端口打开<br>
<img src="https://img-blog.csdnimg.cn/20200506224226754.png" alt="在这里插入图片描述" loading="lazy"><br>
在浏览器中输入：公网ip:刚刚指定的端口，输入密码，即可进入<br>
<img src="https://img-blog.csdnimg.cn/20200506224300542.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/20200506224417486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<code>注</code>：若出现错误</p>
<pre><code class="language-python">OSError: [Errno 99]Cannot assign requested address
</code></pre>
<p>解决方法修改/etc/hosts<br>
首先获取本机内网ip和本机hostname</p>
<pre><code class="language-python">ifconfig    # 获取本机内网ip
vi /etc/hostname    # 获取hostname
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200506224605998.png" alt="在这里插入图片描述" loading="lazy"><br>
进入/etc/hosts，添加上一行内容</p>
<pre><code class="language-python">内网ip   hostname   # 上面获取的那两个
</code></pre>
<p>启动：</p>
<pre><code class="language-python">启动jupyter notebook
(jiqistudy)&gt; jupyter notebook
</code></pre>
<p><code>若出现如下错误，请参考：</code><br>
1.<a href="https://blog.csdn.net/qq_42092076/article/details/105961463">workon: command not found处理方法</a><br>
2.<a href="https://blog.csdn.net/qq_42092076/article/details/105960519">ubuntu安装matplotlib时报错处理</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[workon: command not found处理方法]]></title>
        <id>https://906571331.github.io/yx.github.io/post/8i0Lx-8dx/</id>
        <link href="https://906571331.github.io/yx.github.io/post/8i0Lx-8dx/">
        </link>
        <updated>2020-05-06T14:35:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">$ workon django
$ workon: command not found
</code></pre>
<p>以前安装了虚拟环境，但是使用workon时发现命令不存在，处理方法：重新激活虚拟环境</p>
<pre><code class="language-python"> source /usr/share/virtualenvwrapper/virtualenvwrapper.sh 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ubuntu安装matplotlib时报错处理]]></title>
        <id>https://906571331.github.io/yx.github.io/post/1Ff4JgIDs/</id>
        <link href="https://906571331.github.io/yx.github.io/post/1Ff4JgIDs/">
        </link>
        <updated>2020-05-06T14:32:43.000Z</updated>
        <content type="html"><![CDATA[<p>阿里云安装matplotlib时出现如下错误：</p>
<pre><code class="language-python">(jiqistudy) root@iZ2zeemzp51mlbzarwptwwZ:~# pip install matplotlib
Collecting matplotlib
  Downloading http://mirrors.cloud.aliyuncs.com/pypi/packages/4a/30/eb8e7dd8e3609f05c6920fa82f189302c832e5a0f6667aa96f952056bc0c/matplotlib-3.2.1.tar.gz (40.3MB)
    100% |████████████████████████████████| 40.3MB 29.3MB/s 
    Complete output from command python setup.py egg_info:
    Traceback (most recent call last):
      File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt;
      File &quot;/tmp/pip-build-c_f1ecmg/matplotlib/setup.py&quot;, line 139
        raise IOError(f&quot;Failed to download jquery-ui.  Please download &quot;
                                                                       ^
    SyntaxError: invalid syntax
    
    ----------------------------------------
Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-build-c_f1ecmg/matplotlib/
You are using pip version 8.1.1, however version 20.1 is available.
You should consider upgrading via the 'pip install --upgrade pip' command.
</code></pre>
<p>解决方案：</p>
<pre><code class="language-python">pip install --upgrade setuptools
python -m pip install --upgrade pip
</code></pre>
<p>再次安装matplotlib时就不会报错</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jsp使用request.getParameter时显示乱码的解决方案]]></title>
        <id>https://906571331.github.io/yx.github.io/post/nBa-pdlbR/</id>
        <link href="https://906571331.github.io/yx.github.io/post/nBa-pdlbR/">
        </link>
        <updated>2020-05-03T06:58:34.000Z</updated>
        <content type="html"><![CDATA[<p>Tomcat 7在使用request.getParameter获取前面页面传来的参数值时，会出现乱码的现象，解决方案有两种：<br>
<code>1</code>:使用：</p>
<pre><code class="language-java">&lt;%=new String(request.getParameter(&quot;username&quot;).getBytes(&quot;iso-8859-1&quot;),&quot;UTF-8&quot;) %&gt;
</code></pre>
<p>代替：</p>
<pre><code class="language-java">&lt;%=request.getParameter(&quot;username&quot;) %&gt;
</code></pre>
<p><code>2</code>或者修改server.xml文件，找到此文件，进行修改<br>
<img src="https://img-blog.csdnimg.cn/20200503145111100.png" alt="在这里插入图片描述" loading="lazy"><br>
将<code>useBodyEncodingForURI=&quot;true&quot;</code>改为<code>useBodyEncodingForURI=&quot;false&quot;</code>，效果如图所示：</p>
<pre><code class="language-java">&lt;Connector URIEncoding=&quot;UTF-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; redirectPort=&quot;8443&quot; useBodyEncodingForURI=&quot;false&quot;/&gt;
</code></pre>
<p><code>useBodyEncodingForURI</code>参数表示是否用<code>request.setCharacterEncoding</code>参数对URL提交的数据和表单中GET方式提交的数据进行重新编码，在默认情况下，该参数为<code>false</code>。<br>
URIEncoding参数指定对所有GET方式请求进行统一的重新编码（解码）的编码。<br>
<code>JSP</code>中其他常见的问题<br>
<code>1</code><a href="https://blog.csdn.net/qq_42092076/article/details/104790088">解决jsp开发中eclipse无法创建Dynamic web project</a></p>
<p><code>2</code><a href="https://blog.csdn.net/qq_42092076/article/details/104789471">解决JSP开发中出现的Tomcat启动时闪退的问题</a></p>
<p><code>3</code><a href="https://blog.csdn.net/qq_42092076/article/details/104936671">JSP开发中tomcat访问URL带有中文名称的HTML文件显示404错误</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django获取各种形式的表单内容]]></title>
        <id>https://906571331.github.io/yx.github.io/post/y4MYiiqzl/</id>
        <link href="https://906571331.github.io/yx.github.io/post/y4MYiiqzl/">
        </link>
        <updated>2020-04-27T11:16:45.000Z</updated>
        <content type="html"><![CDATA[<p>Django框架获取各种form表单数据</p>
<h4 id="1django中获取textpassword">1.Django中获取text，password</h4>
<pre><code class="language-python">　　名字：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br&gt;&lt;br&gt;
　　密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;
</code></pre>
<p>Form表单提交数据时使用的是post方式，所以在后端接收参数的时候需要先判断请求方式为post时才能请求到数据</p>
<pre><code class="language-python">　　name = request.POST.get('name')
　　password = request.POST.get('password')
</code></pre>
<h4 id="2django中获取单选框">2.Django中获取单选框</h4>
<pre><code class="language-python">　　性别：&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;man&quot;&gt;男
　　　　&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;woman&quot;&gt;女
　　　　#此时获取到的值是woman或者man
　　　　gender = request.POST.get('gender')
</code></pre>
<h4 id="3django中获取单选的复选框">3.Django中获取单选的复选框</h4>
<p>单选复选框：<input type="checkbox" name="is_tuanyuan" value="is_tuanyuan">是否是团员</p>
<p>此时如果选中该选项，获取到的值是value后面的，若没有选中即是None</p>
<pre><code class="language-python">　　is_tuanyuan = request.POST.get('is_tuanyuan')
</code></pre>
<p>Django中获取复选框</p>
<pre><code class="language-python">　　复选框：&lt;input type=&quot;checkbox&quot; name=&quot;joy&quot; value=&quot;sing&quot;&gt;唱歌

　　　　　　&lt;input type=&quot;checkbox&quot; name=&quot;joy&quot; value=&quot;dance&quot;&gt;跳舞
</code></pre>
<p>这里应该使用getlist获取多选框，获取到的是列表形式，用get获取只能得到最后一个选项</p>
<pre><code class="language-python">　　joy = request.POST.getlist('joy')
</code></pre>
<h4 id="4django中获取单选下拉框">4.Django中获取单选下拉框</h4>
<p>去过哪些城市？单选</p>
<pre><code class="language-python">　　&lt;select name=&quot;city&quot;&gt;
　　　　&lt;option&gt;北京&lt;/option&gt;
　　　　&lt;option&gt;天津&lt;/option&gt;
　　　　&lt;option&gt;南京&lt;/option&gt;
　　&lt;/select&gt;
</code></pre>
<p>这里获取到的就直接是option里面的内容</p>
<pre><code class="language-python">　　city = request.POST.get('city')
</code></pre>
<p>Django中获取多选的下拉框</p>
<pre><code class="language-python">#去过哪些城市？多选
　　&lt;select multiple name=&quot;more_city&quot;&gt;
　　　　&lt;option&gt;北京&lt;/option&gt;
　　　　&lt;option&gt;天津&lt;/option&gt;
　　　　&lt;option&gt;南京&lt;/option&gt;
　　&lt;/select&gt;
</code></pre>
<p>这里涉及到多个值得获取，需要使用getlist，获取到的是列表，get依然只能获取到一个值，用户在使用时按住Ctrl即可以实现多选</p>
<pre><code class="language-python">　　 more_city = request.POST.getlist('more_city') 
</code></pre>
<h4 id="5django中获取文本域">5.Django中获取文本域</h4>
<pre><code class="language-python">　　&lt;textarea name=&quot;more_text&quot; placeholder=&quot;请输入备注&quot;&gt;&lt;/textarea&gt;
</code></pre>
<p>获取方法：</p>
<pre><code class="language-python">　　more_text = request.POST.get('more_text')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ueditor在Django中的使用]]></title>
        <id>https://906571331.github.io/yx.github.io/post/4y-2Nv7x-/</id>
        <link href="https://906571331.github.io/yx.github.io/post/4y-2Nv7x-/">
        </link>
        <updated>2020-04-27T09:10:16.000Z</updated>
        <content type="html"><![CDATA[<p>在修改models.py中的字段后，需要进行数据库的迁移</p>
<pre><code class="language-python">#urls.py
path('ueditor/',include('DjangoUeditor.urls' )),
</code></pre>
<pre><code class="language-python">#adminx.py
class QuestionAdmin(object):
	#可以显示的列
    list_display=[&quot;subject&quot;,&quot;statments&quot;,&quot;op_A&quot;,&quot;op_B&quot;,&quot;op_C&quot;,&quot;op_D&quot;]
    #查找的设置
    search_fields=[&quot;subject&quot;,&quot;statments&quot;,&quot;op_A&quot;,&quot;op_B&quot;,&quot;op_C&quot;,&quot;op_D&quot;]
    #过滤器的设置
    list_filter=[&quot;subject&quot;,&quot;statments&quot;,&quot;op_A&quot;,&quot;op_B&quot;,&quot;op_C&quot;,&quot;op_D&quot;]
    #可以在当前页面编辑的列，当后台设置为ueditor时，这里设置为不能修改，否则会报错
    #list_editable=[&quot;subject&quot;,&quot;statments&quot;,&quot;op_A&quot;,&quot;op_B&quot;,&quot;op_C&quot;,&quot;op_D&quot;]
    model_icon=&quot;fa fa-bath&quot;
    #将statements字段设置为ueditor类型
    style_fields = {&quot;statments&quot;: &quot;ueditor&quot;}
</code></pre>
<pre><code class="language-python">#models.py中的设置：
from DjangoUeditor.models import UEditorField
class Question(models.Model):
	choice = (('A','A'),('B','B'),('C','C'),('D','D'))
	subject 	= models.ForeignKey(Subject,on_delete=models.CASCADE,verbose_name=&quot;考试科目&quot;)
	# statments 	= models.TextField(verbose_name=&quot;问题描述&quot;)
	statments = UEditorField(verbose_name=u'题目描述', width=600, height=300, imagePath=&quot;exam/ueditor/&quot;,
						  filePath=&quot;exam/ueditor/&quot;, default='')
	op_A 	= models.CharField(max_length=1000)
	op_B 	= models.CharField(max_length=1000)
	op_C 	= models.CharField(max_length=1000)
	op_D 	= models.CharField(max_length=1000)
	correct_op 	= models.CharField(choices=choice,max_length=10)
	mark 		= models.IntegerField(default=1)
	class Meta:
		verbose_name=&quot;题目&quot;
		verbose_name_plural=verbose_name
	def __str__(self):
		return self.statments
</code></pre>
<pre><code class="language-html">        {#每一道题的描述#}
        &lt;td&gt;{% autoescape off %}
             {{ foo.statments}}
             {% endautoescape %}&lt;/td&gt;
           &lt;br&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200427171242288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在Django中引入日志功能：]]></title>
        <id>https://906571331.github.io/yx.github.io/post/XOKY2QSij/</id>
        <link href="https://906571331.github.io/yx.github.io/post/XOKY2QSij/">
        </link>
        <updated>2020-04-27T07:39:16.000Z</updated>
        <content type="html"><![CDATA[<p><code>在Django中引入日志功能：</code><br>
<code>1.</code>在settings.py中加入以下代码：</p>
<pre><code class="language-python">LOGGING = {
    # 版本
    'version': 1,
    # 是否禁用已存在的日志器
    'disable_existing_loggers': False,
    'formatters': {
        'verbose': {
            'formrat': '%(levelname)s %(asctime)s %(module)s %(lineno)d %(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(module)s %(lineno)d %(message)s'
        },
    },
    'filters': {
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },
    },
    'handlers': {
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'],
            'class': 'logging.StreamHandler',
            'formatter': 'simple'
        },
        'file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': os.path.join(BASE_DIR, &quot;logs/user.log&quot;),  # 日志文件的位置
            'maxBytes': 300 * 1024 * 1024,
            'backupCount': 10,
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {  # 定义了一个名为django的日志器
            'handlers': ['console', 'file'],
            'propagate': True,
            'level': 'INFO',  # 日志器接收的最低日志级别
        },
    }
</code></pre>
<p><code>2.</code>新建一个名为logs的文件夹，重新启动Django项目即可将日志记录到user.logs的文件中</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django实现考试系统优化2]]></title>
        <id>https://906571331.github.io/yx.github.io/post/0H_lhPduB/</id>
        <link href="https://906571331.github.io/yx.github.io/post/0H_lhPduB/">
        </link>
        <updated>2020-04-26T11:05:10.000Z</updated>
        <content type="html"><![CDATA[<p><code>时间：2020年4月26日18:51:43</code><br>
Django实现考试系统优化：实现从数据库中读取分数，并且计算分数，修改数据分数的数据类型为IntegerField，判断用户是否已经进行了测试，如果进行了测试，则不能再次测试</p>
<pre><code class="language-python">#models.py
#user/models.py
class UserProfile(AbstractUser):

    gender_choices = (
        ('male','男'),
        ('female','女')
    )

    nick_name = models.CharField('昵称',max_length=50,default='',blank=True)
    birthday = models.DateField('生日',null=True,blank=True)
    gender = models.CharField('性别',max_length=10,choices=gender_choices,default='female')
    adress = models.CharField('地址',max_length=100,default='')
    mobile = models.CharField('手机号',max_length=11,null=True,blank=True)
    image = models.ImageField(upload_to='image/%Y%m',default='image/default.png',max_length=100,blank=True)
    is_exam=models.BooleanField(default=False,verbose_name=&quot;是否进行了测试&quot;)
    class Meta:
        verbose_name = '用户信息'
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.username
#models.py
from django.db import models
from datetime import datetime
# Create your models here.
from django.db import models
from users.models import UserProfile
# Create your models here.

#科目
class Subject(models.Model):
	name 			= models.CharField(max_length=255,verbose_name=&quot;科目名称&quot;)
	description 	= models.TextField(verbose_name=&quot;科目描述&quot;)
	cover_image 	= models.ImageField(upload_to = 'cover/',blank=True)
	class Meta:
		verbose_name=&quot;科目&quot;
		verbose_name_plural=verbose_name
	def __str__(self):
		return self.name

class Question(models.Model):
	choice = (('A','A'),('B','B'),('C','C'),('D','D'))
	subject 	= models.ForeignKey(Subject,on_delete=models.CASCADE,verbose_name=&quot;考试科目&quot;)
	statments 	= models.TextField(verbose_name=&quot;问题描述&quot;)
	op_A 	= models.CharField(max_length=1000)
	op_B 	= models.CharField(max_length=1000)
	op_C 	= models.CharField(max_length=1000)
	op_D 	= models.CharField(max_length=1000)
	correct_op 	= models.CharField(choices=choice,max_length=10)
	mark 		= models.IntegerField(default=1)
	class Meta:
		verbose_name=&quot;题目&quot;
		verbose_name_plural=verbose_name
	def __str__(self):
		return self.statments


class Exam(models.Model):
	user = models.ForeignKey(UserProfile,on_delete=models.CASCADE,verbose_name=&quot;用户&quot;)
	subject = models.ForeignKey(Subject,on_delete=models.CASCADE,verbose_name=&quot;考试科目&quot;)
	name = models.CharField(max_length=100,blank=True,verbose_name=&quot;本次考试名称&quot;)
	class Meta:
		verbose_name=&quot;考试&quot;
		verbose_name_plural=verbose_name
	def __str__(self):
		return self.name

class Mark(models.Model):
	user = models.ForeignKey(UserProfile,on_delete=models.CASCADE,verbose_name=&quot;用户&quot;)
	subject = models.ForeignKey(Subject,on_delete=models.CASCADE,verbose_name=&quot;考试科目&quot;)
	exam = models.ForeignKey(Exam,on_delete=models.CASCADE,verbose_name=&quot;考试名称&quot;)
	total_mark = models.IntegerField(verbose_name=&quot;总分数&quot;)
	base_mark = models.IntegerField(verbose_name=&quot;基础分数&quot;)
	promote_mark = models.IntegerField(verbose_name=&quot;提升分数&quot;)
	major_mark = models.IntegerField(verbose_name=&quot;专业分数&quot;)
	class Meta:
		verbose_name=&quot;分数&quot;
		verbose_name_plural=verbose_name
	def __str__(self):
		return str(self.total_mark)

class Keshi(models.Model):
    keshi = models.CharField(max_length=10, verbose_name=&quot;分数可视化&quot;)
    class Meta:
        verbose_name = &quot;分数可视化&quot;
        verbose_name_plural = verbose_name
</code></pre>
<pre><code class="language-python">#views.py
from django.shortcuts import render
from django.views.generic import View
from django.http import HttpResponse
from .models import Question,Exam,Subject,Mark
from django.db.models import Count
from django.contrib.auth.decorators import login_required
from users.models import UserProfile
# Create your views here.
from django.utils.decorators import method_decorator
@method_decorator(login_required,name='dispatch')
class ExamView(View):
    def get(self,request):
        uid = request.user
        #查看是否已经进行过该考试，如果进行过该次考试，则不能再次考试
        if uid.is_exam==True:
            return HttpResponse(&quot;您已进行过改考试，无需再次考试&quot;)
        else:
            #获取id=1的科目
            subjetcs1=Subject.objects.get(id=1)
            #打印这个科目的名称，可省去
            print(subjetcs1)
            #获取到这个科目下的所有试题
            question=Question.objects.filter(subject=subjetcs1)
            context={
                &quot;question&quot;:question,
            }
            return render(request, &quot;exam03.html&quot;,context=context)
    def post(self,request):
        #获取是哪个用户
        uid = request.user
        print(uid.is_exam)
        #获取当前用户的昵称
        uname=request.user.nick_name
        #获取当前考试的学科
        subjetcs1 = Subject.objects.get(id=1)
        #获取是哪次考试
        current_exam=Exam.objects.get(id=1)
        print(&quot;本次考试的科目为：&quot;,subjetcs1)
        print(&quot;本次考试名称为：&quot;, current_exam)
        print(uid)
        print(uname)
        #获取用户的答案
        my_answer = []
        #这里获取总的题目数量，添加题目数量后无需继续修改这里的数据
        count_question = Question.objects.aggregate(count=Count(&quot;id&quot;))
        for c in count_question.values():
            print(c)
        count1=c
        print(count1)
        for i in range(1,count1+1):
            answer1 = request.POST.get('%s'%i)
            my_answer.append(answer1)
            i+=1
        print(&quot;用户答案为：&quot;,my_answer)
        # 打印所有题目的正确答案
        correct_answer=re(request)
        timu_fenshu=fenshu(request)
        print(&quot;题目分数为：&quot;, timu_fenshu)
        print(&quot;正确答案为：&quot;,correct_answer)
        #基础，提升，专业分数,总分数均初始化为0
        base_mark=0
        promote_mark=0
        major_mark=0
        total_mark=0
        i=0
        while i &lt;=count1-1 :
            if i &lt;= 0:
                if correct_answer[i] == my_answer[i]:
                    base_mark += timu_fenshu[i]
                    total_mark = total_mark + timu_fenshu[i]
            elif i &lt;= 1:
                if correct_answer[i] == my_answer[i]:
                    total_mark = total_mark+timu_fenshu[i]
                    promote_mark += timu_fenshu[i]
            else:
                if correct_answer[i] == my_answer[i]:
                    total_mark = total_mark+timu_fenshu[i]
                    print(timu_fenshu[i])
                    major_mark += timu_fenshu[i]
            i = i + 1
        print(&quot;总分数为：&quot;, total_mark)
        print(&quot;基础分数为：&quot;, base_mark)
        print(&quot;提升分数为：&quot;, promote_mark)
        print(&quot;专业分数为：&quot;, major_mark)
        mark=Mark(user=uid,subject=subjetcs1,total_mark=total_mark,exam=current_exam,base_mark=base_mark,promote_mark=promote_mark,major_mark=major_mark)
        uid.is_exam=True
        uid.save()
        mark.save()
        return render(request,'commite_succcess.html')

#打印所有题目的正确答案
def re(request):
    option_list = []
    options=Question.objects.all()
    for option in options:
        option_list.append(option.correct_op)
    return option_list
#获取每一道题的分数
def fenshu(request):
    fenshu_list = []
    fenshus=Question.objects.all()
    for fenshu in fenshus:
        fenshu_list.append(fenshu.mark)
    return fenshu_list
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200426190338777.png" alt="在这里插入图片描述" loading="lazy"></figure>
<p><code>以前的文章：</code><br>
<code>1.</code><a href="https://blog.csdn.net/qq_42092076/article/details/105713551">Django实现考试系统,并实现后台数据可视化</a></p>
<p><code>2.</code><a href="https://blog.csdn.net/qq_42092076/article/details/105664258">django考试试卷的实现【1】</a></p>
<p><code>3.</code><a href="https://blog.csdn.net/qq_42092076/article/details/105649783">计算分数算法</a></p>
<p><code>4.</code><a href="https://blog.csdn.net/qq_42092076/article/details/105752469">Django2中@login_required的用法</a></p>
<p><code>5.</code><a href="https://blog.csdn.net/qq_42092076/article/details/105565647">django-xadmin实现自定义后台，进行个性化显示</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django聚合函数笔记]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django-ju-he-han-shu-bi-ji/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django-ju-he-han-shu-bi-ji/">
        </link>
        <updated>2020-04-25T10:37:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="聚合函数笔记">聚合函数笔记：</h3>
<ol>
<li>
<p>所有的聚合函数都是放在<code>django.db.models</code>下面。</p>
</li>
<li>
<p>聚合函数不能够单独的执行，需要放在一些可以执行聚合函数的方法下面中去执行。比如<code>aggregate</code>。示例代码如下：</p>
<pre><code class="language-python">result = Book.objects.aggregate(Avg(&quot;price&quot;))
</code></pre>
</li>
<li>
<p>聚合函数执行完成后，给这个聚合函数的值取个名字。取名字的规则，默认是<code>filed+__+聚合函数名字</code>形成的。比如以上代码形成的名字叫做<code>price__avg</code>。如果不想使用默认的名字，那么可以在使用聚合函数的时候传递关键字参数进去，参数的名字就是聚合函数执行完成的名字。实示例代码如下：</p>
<pre><code class="language-python">result = Book.objects.aggregate(avg=Avg(&quot;price&quot;))
</code></pre>
<p>以上传递了关键字参数<code>avg=Avg(&quot;price&quot;)</code>，那么以后<code>Avg</code>聚合函数执行完成的名字就叫做<code>avg</code>。</p>
</li>
<li>
<p><code>aggregate</code>：这个方法不会返回一个<code>QuerySet</code>对象，而是返回一个字典。这个字典中的key就是聚合函数的名字，值就是聚合函数执行后的结果。</p>
</li>
<li>
<p><code>aggregate</code>和<code>annotate</code>的相同和不同：</p>
<ul>
<li>相同：这两个方法都可以执行聚合函数。</li>
<li>不同：
<ul>
<li><code>aggregate</code>返回的是一个字典，在这个字典中存储的是这个聚合函数执行的结果。而<code>annotate</code>返回的是一个<code>QuerySet</code>对象，并且会在查找的模型上添加一个聚合函数的属性。</li>
<li><code>aggregate</code>不会做分组，而<code>annotate</code>会使用<code>group by</code>子句进行分组，只有调用了<code>group by</code>子句，才能对每一条数据求聚合函数的值。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Count</code>：用来求某个数据的个数。比如要求所有图书的数量，那么可以使用以下代码：</p>
<pre><code class="language-python">result = Book.objects.aggregate(book_nums=Count(&quot;id&quot;))
</code></pre>
<p>并且<code>Count</code>可以传递<code>distinct=True</code>参数，用来剔除那些重复的值，只保留一个。比如要获取作者表中，不同邮箱的个数，那么这时候可以使用<code>distinct=True</code>。示例代码如下：</p>
<pre><code class="language-python">result = Author.objects.aggregate(email_nums=Count('email',distinct=True))
</code></pre>
</li>
<li>
<p><code>Max</code>和<code>Min</code>：求指定字段的最大值和最小值。示例代码如下：</p>
<pre><code class="language-python">result = Author.objects.aggregate(max=Max(&quot;age&quot;),min=Min(&quot;age&quot;))
</code></pre>
</li>
<li>
<p><code>Sum</code>：求某个字段值的总和。示例代码如下：</p>
<pre><code class="language-python">result = BookOrder.objects.aggregate(total=Sum('price'))
</code></pre>
<p><code>aggregate</code>和<code>annotate</code>方法可以在任何的<code>QuerySet</code>对象上调用。因此只要是返回了<code>QuerySet</code>对象，那么就可以进行链式调用。比如要获取2018年度的销售总额，那么可以先过滤年份，再求聚合函数。示例代码如下：</p>
<pre><code class="language-python">BookOrder.objects.filter(create_time__year=2018).aggregate(total=Sum('price'))
</code></pre>
</li>
<li>
<p><code>F表达式</code>： 动态的获取某个字段上的值。并且这个F表达式，不会真正的去数据库中查询数据，他相当于只是起一个标识的作用。比如想要将原来每本图书的价格都在原来的基础之上增加10元，那么可以使用以下代码来实现：</p>
<pre><code class="language-python">from django.db.models import F
Book.objects.update(price=F(&quot;price&quot;)+10)
</code></pre>
</li>
<li>
<p><code>Q表达式</code>：使用<code>Q</code>表达式包裹查询条件，可以在条件之间进行多种操作。与/或非等，从而实现一些复杂的查询操作。例子如下：</p>
<ul>
<li>查找价格大于100，并且评分达到4.85以上的图书：<pre><code class="language-python"># 不使用Q表达式的
books = Book.objects.filter(price__gte=100,rating__gte=4.85)
# 使用Q表达式的
books = Book.objects.filter(Q(price__gte=100)&amp;Q(rating__gte=4.85))
</code></pre>
</li>
<li>查找价格低于100元，或者评分低于4分的图书：<pre><code class="language-python">books = Book.objects.filter(Q(price__gte=100)&amp;Q(rating__gte=4.85))
</code></pre>
</li>
<li>获取价格大于100，并且图书名字中不包含”传“字的图书：<pre><code class="language-python">books = Book.objects.filter(Q(price__gte=100)&amp;~Q(name__icontains='传'))
</code></pre>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django2中@login_required的用法]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django2-zhong-login_required-de-yong-fa/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django2-zhong-login_required-de-yong-fa/">
        </link>
        <updated>2020-04-25T08:58:07.000Z</updated>
        <content type="html"><![CDATA[<h4 id="在开发中会遇到这样的需求即在用户未登录时不对用户开放某些页面这种需求在django2中解决办法为">在开发中会遇到这样的需求：即在用户未登录时不对用户开放某些页面，这种需求在Django2中解决办法为：</h4>
<ul>
<li><code>1.在settings.py中添加：</code></li>
</ul>
<pre><code class="language-python">#settings.py
AUTH_USER_MODEL = 'users.UserProfile'
#这个根据登录URL的不同进行修改
LOGIN_URL=&quot;login&quot;
#附：urls.py中的设置：
    path('login/',LoginView.as_view(),name = 'login'),
</code></pre>
<ul>
<li><code>2.在相应的视图中添加：</code></li>
</ul>
<pre><code class="language-python">from django.contrib.auth.decorators import login_required
# Create your views here.
from django.utils.decorators import method_decorator
@method_decorator(login_required,name='dispatch')
</code></pre>
<p>同时解决使用<code>@login_required</code>后出现<code>'function' object has no attribute 'as_view'</code>的问题，解决方案：<code>使用以上的方法</code></p>
]]></content>
    </entry>
</feed>