<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://906571331.github.io/yx.github.io/</id>
    <title>WuXin</title>
    <updated>2020-04-19T12:21:25.732Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://906571331.github.io/yx.github.io/"/>
    <link rel="self" href="https://906571331.github.io/yx.github.io/atom.xml"/>
    <subtitle>成千上万个门口，总有一个人要先走。</subtitle>
    <logo>https://906571331.github.io/yx.github.io/images/avatar.png</logo>
    <icon>https://906571331.github.io/yx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WuXin</rights>
    <entry>
        <title type="html"><![CDATA[设置`<iframe>`标签的大小]]></title>
        <id>https://906571331.github.io/yx.github.io/post/she-zhi-lessiframegreaterbiao-qian-de-da-xiao/</id>
        <link href="https://906571331.github.io/yx.github.io/post/she-zhi-lessiframegreaterbiao-qian-de-da-xiao/">
        </link>
        <updated>2020-04-19T12:20:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id=""></h4>
<p><code>&lt;ifrarme&gt;</code>标签的大小设置，Django填入<code>&lt;ifrarme&gt;</code>标签后自动设置大小</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;style&gt;
        .container{
       width: 1700px;
            height:500px;
       margin: 0 auto;
       border: 1px solid #f00;
       text-align: center;
     }
 iframe{
         border: 1px solid #000;
       width: 1700px;
         height: 600px;
     }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

 &lt;div class=&quot;container&quot;&gt;
 {% autoescape off %}
     {{ info }}
     {% endautoescape %}
 &lt;/div&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-python">def bofang(request):
    context={
        &quot;info&quot;:'&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=455345011&amp;bvid=BV1x5411x7kE&amp;cid=179274496&amp;page=1&quot; scrolling=&quot;yes&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; &gt; &lt;/iframe&gt;'
    }
    return render(request,&quot;bofang.html&quot;,context=context)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[pycharm连接虚拟机中的django项目]]></title>
        <id>https://906571331.github.io/yx.github.io/post/pycharm-lian-jie-xu-ni-ji-zhong-de-django-xiang-mu/</id>
        <link href="https://906571331.github.io/yx.github.io/post/pycharm-lian-jie-xu-ni-ji-zhong-de-django-xiang-mu/">
        </link>
        <updated>2020-04-18T08:48:19.000Z</updated>
        <content type="html"><![CDATA[<p>1.在配置好环境以后，打开pycharm，点击文件，新项目，创建一个Pure Python项目，打开添加远程<br>
<img src="https://img-blog.csdnimg.cn/20200418162635495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
2.点击SSH，按下面的要求进行配置<br>
<img src="https://img-blog.csdnimg.cn/20200418163337630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
进来以后发现，显示没有文件，<br>
<img src="https://img-blog.csdnimg.cn/20200418163501574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
3.接下来点击工具--&gt;&gt;Deployment---&gt;&gt;Configuration<br>
<img src="https://img-blog.csdnimg.cn/20200418163550530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020041816394794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
在Mappings中的设置：<br>
<img src="https://img-blog.csdnimg.cn/20200418164055119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
4.点击确定，在左侧的目录栏中，右击项目名称----&gt;Deployment---&gt;Download，从虚拟机中将项目导入<br>
<img src="https://img-blog.csdnimg.cn/20200418164159667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<code>常见的问题</code><br>
1.下次打开虚拟机，发现虚拟机中的项目无法正确导入，可能是虚拟机中的ip已换，解决方案请移步：<a href="https://blog.csdn.net/qq_42092076/article/details/105263238">解决Django开发中pycharm连接不到虚拟机的问题</a><br>
2.其他问题可关注博客：<a href="https://blog.csdn.net/qq_42092076">博客</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django+xadmin+echarts在后台动态显示echarts图表，实现后台定制化开发]]></title>
        <id>https://906571331.github.io/yx.github.io/post/djangoxadminecharts-zai-hou-tai-dong-tai-xian-shi-echarts-tu-biao-shi-xian-hou-tai-ding-zhi-hua-kai-fa/</id>
        <link href="https://906571331.github.io/yx.github.io/post/djangoxadminecharts-zai-hou-tai-dong-tai-xian-shi-echarts-tu-biao-shi-xian-hou-tai-ding-zhi-hua-kai-fa/">
        </link>
        <updated>2020-04-17T02:29:13.000Z</updated>
        <content type="html"><![CDATA[<p>本篇博客将Django+xadmin+echarts在后台动态显示echarts图表</p>
<pre><code class="language-python">#app/adminx.py
#从user模型中导入User表
from users.models import User
class ChangeIntoAdmin(object):
    # 指向自定义的页面
    object_list_template = 'base111.html'
    # 重写方法，把要展示的数据更新到 context
    def get_context(self):
        context = CommAdminView.get_context(self)
        #获取所有的用户
        users = User.objects.all()
        #获取用户的一个属性，将显示到
        base_list = []
        #获取用户名
        name_list = []
        for user in users:
            name_list.append(user.name)
            base_list.append(user.base_mark)
        context.update(
            {
                'name_list': name_list,
                'base_list': base_list,
            }
        )
        return context
#进行注册
xadmin.site.register(Book, ChangeIntoAdmin)
</code></pre>
<pre><code class="language-html">#base111.html
{# 继承自xadmin中的base_site.html #}
{% extends 'xadmin/base_site.html' %}

{# 去掉标签栏 #}
{% block content-nav %}

{% endblock %}
{% block extrastyle %}
{#这个block块中添加echarts.min.js，前提是在static文件夹下放入echarts.min.js,也可以引入其他样式，这个块是在xadmin/base.html中#}
&lt;script src=&quot;{% static 'js/echarts.min.js' %}&quot;  charset=&quot;utf-8&quot;&gt;&lt;/script&gt;
{% endblock %}
{% block content %}
&lt;div&gt;zhelishige
    &lt;div id=&quot;chart_1&quot; style=&quot;width:500px; height:500px&quot;&gt;在这里&lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var myChart = echarts.init(document.getElementById('chart_1'));
option = {
    xAxis: {
        type: 'category',
        boundaryGap: false,
        {# 这里是填入的数据 #}
        data: {{ name_list|safe }}
    },
    yAxis: {
        type: 'value'
    },
    series: [{
    	{# 这里是填入的数据 #}
        data:{{base_list}},
        type: 'line',
        areaStyle: {}
    }]
};
myChart.setOption(option);
&lt;/script&gt;
{% endblock content %}
</code></pre>
<p><code>显示效果</code>（修改css样式即可显示的更加美观）<br>
<img src="https://img-blog.csdnimg.cn/20200417102244216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
<code>常见的一些问题：</code><br>
1.在添加echarts后，左侧导航栏显示<code>你没有权限修改任何东西</code>的错误，请移步：<a href="https://blog.csdn.net/qq_42092076/article/details/105572667">Django2.1.7 xadmin后台开发中出现“你无权修改任何东西”的错误</a><br>
2.<code>echarts中div层不显示</code>：可能是在div中没有添加css样式，解决方案，<code>在相应的div中添加样式</code>，如下所示：</p>
<pre><code class="language-html">&lt;div id=&quot;chart_1&quot; style=&quot;width:500px; height:500px&quot;&gt;&lt;/div&gt;
</code></pre>
<p><code>其他优化xadmin方法，以及解决方案：</code><br>
1.<a href="https://blog.csdn.net/qq_42092076/article/details/105440673">Django的开发中遇到的一些问题以及解决方案，包括Django-xadmin的优化</a><br>
2.<a href="https://blog.csdn.net/qq_42092076/article/details/105565647">django-xadmin实现自定义后台，进行个性化显示</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django2.1.7 xadmin后台开发中出现“你无权修改任何东西”的错误]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django217-xadmin-hou-tai-kai-fa-zhong-chu-xian-ni-wu-quan-xiu-gai-ren-he-dong-xi-de-cuo-wu/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django217-xadmin-hou-tai-kai-fa-zhong-chu-xian-ni-wu-quan-xiu-gai-ren-he-dong-xi-de-cuo-wu/">
        </link>
        <updated>2020-04-17T01:14:34.000Z</updated>
        <content type="html"><![CDATA[<p>Django2.1.7 xadmin后台开发中出现“你无权修改任何东西”的错误<img src="https://img-blog.csdnimg.cn/20200417090859980.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="解决的办法">解决的办法</h4>
<pre><code class="language-python">from users.models import User
class ChangeIntoAdmin(object):
    # 指向自定义的页面
    object_list_template = 'base111.html'
    # 重写方法，把要展示的数据更新到 context
    def get_context(self):
        context = CommAdminView.get_context(self)
        users = User.objects.all()
        base_list = []
        name_list = []
        for user in users:
            name_list.append(user.name)
            base_list.append(user.base_mark)
        context.update(
            {
                'name_list': name_list,
                'base_list': base_list,
            }
        )
        return context
#注册，其中Book是一张表
xadmin.site.register(Book, ChangeIntoAdmin)
</code></pre>
<pre><code class="language-html">#继承自xadmin/base_site.html模板
{% extends 'xadmin/base_site.html' %}

{# 去掉标签栏 #}
{% block content-nav %}

{% endblock %}

{% block content %}
{{ name_list|safe }}
    {{ base_list }}
{% endblock content %}
</code></pre>
<p>即可正确显示<br>
<img src="https://img-blog.csdnimg.cn/2020041709130918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django-xadmin实现自定义后台，进行个性化显示]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django-xadmin-shi-xian-zi-ding-yi-hou-tai-jin-xing-ge-xing-hua-xian-shi/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django-xadmin-shi-xian-zi-ding-yi-hou-tai-jin-xing-ge-xing-hua-xian-shi/">
        </link>
        <updated>2020-04-16T12:03:33.000Z</updated>
        <content type="html"><![CDATA[<p>在实际的开发中，通常需要对Django的后台管理页面进行个性化定制，本篇博客将介绍如何个性化定制后台。</p>
<h4 id="1在任意的adminx中自定义类如下所示">1.在任意的adminx中自定义类，如下所示：</h4>
<pre><code class="language-python">#adminx.py
class ChangeIntoAdmin(object):
    # 指向自定义的页面，并且在templates创建名字为base111.html的页面
    object_list_template = 'base111.html'
    # 重写方法，把要展示的数据更新到 context
    def get_context(self):
    	#读取所需要的数据
        context = CommAdminView.get_context(self)
        bill_message = Book.objects.all()
        context.update(
            {
                'title': '转入分析',
            }
        )
        return context
#进行注册，注册到名字为Book的列表页下面
xadmin.site.register(Book, ChangeIntoAdmin)
</code></pre>
<pre><code class="language-html"># base111.html
#继承自xadmin/base_site.html
{% extends 'xadmin/base_site.html' %}

{# 去掉标签栏 #}
{% block content-nav %}

{% endblock %}

{% block content %}
#显示传入的数据
{{ title }}
{% endblock content %}
</code></pre>
<p>效果如下：<img src="https://img-blog.csdnimg.cn/20200416200122973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
未修改前：<br>
<img src="https://img-blog.csdnimg.cn/20200416200108299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django开发中遇到No module named 'captcha的问题解决方法]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django-kai-fa-zhong-yu-dao-no-module-named-captcha-de-wen-ti-jie-jue-fang-fa/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django-kai-fa-zhong-yu-dao-no-module-named-captcha-de-wen-ti-jie-jue-fang-fa/">
        </link>
        <updated>2020-04-16T08:26:23.000Z</updated>
        <content type="html"><![CDATA[<h4 id="在django开发中遇到如下问题">在Django开发中遇到如下问题</h4>
<pre><code class="language-python">    from captcha.fields import CaptchaField
ModuleNotFoundError: No module named 'captcha.fields'
</code></pre>
<h4 id="解决方法">解决方法：</h4>
<p>安装django-simple-captcha</p>
<pre><code class="language-python">pip install django-simple-captcha
</code></pre>
<h4 id="在开发中遇到以下错误">在开发中遇到以下错误</h4>
<pre><code class="language-python">HINT: Add or change a related_name argument to the definition for 'User.user_permissions' or 'UserProfile.user_permissions'.
</code></pre>
<p>解决方案：在settings.py中添加：</p>
<pre><code class="language-python">AUTH_USER_MODEL = 'Users.UserProfile'
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django的开发中遇到的一些问题以及解决方案，包括Django-xadmin的优化]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django-de-kai-fa-zhong-yu-dao-de-yi-xie-wen-ti-yi-ji-jie-jue-fang-an-bao-gua-django-xadmin-de-you-hua/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django-de-kai-fa-zhong-yu-dao-de-yi-xie-wen-ti-yi-ji-jie-jue-fang-an-bao-gua-django-xadmin-de-you-hua/">
        </link>
        <updated>2020-04-15T12:01:09.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1python报错">1.Python报错：</h4>
<pre><code class="language-Python">   	from django.urls import path, include
ImportError: cannot import name 'path'
</code></pre>
<p>解决方法：可能是Django的版本问题，查看当前虚拟环境的Django版本</p>
<pre><code class="language-python">import django
django._get_version()
</code></pre>
<p>如果Django的版本低于之前的版本，使用pip install django==版本号<br>
升级Django到对应的版本</p>
<h4 id="2django中引入写好的文件即服务器不需要传入任何参数只需修改urlspy其他不用修改用途编写abouthtml">2.django中引入写好的文件，即服务器不需要传入任何参数,只需修改urls.py，其他不用修改，用途：编写about.html</h4>
<pre><code class="language-python">#urls.py
from django.views.generic import TemplateView
path(&quot;about/&quot;,TemplateView.as_view(template_name=&quot;about.html&quot;)),
</code></pre>
<h4 id="3ubuntu中python环境下载mysqlclient出错">3.ubuntu中Python环境下载mysqlclient出错：</h4>
<pre><code class="language-python">x86_64-linux-gnu-gcc -pthread -DNDEBUG -g -fwrapv -O2 -Wall -Wstrict-prototypes -fno-strict-aliasing -D_FORTIFY_SOURCE=2 -g -fstack-protector-strong -Wformat -Werror=format-security -fPIC -I/tmp/pip-build-Hqt4sF/lxml/src/lxml/includes -I/usr/include/python2.7 -c src/lxml/lxml.etree.c -o build/temp.linux-x86_64-2.7/src/lxml/lxml.etree.o -w

In file included from src/lxml/lxml.etree.c:239:0:

/tmp/pip-build-Hqt4sF/lxml/src/lxml/includes/etree_defs.h:14:31: fatal error: libxml/xmlversion.h: No such file or directory

compilation terminated.

error: command 'x86_64-linux-gnu-gcc' failed with exit status 1

----------------------------------------
  Can't roll back lxml; was not uninstalled
Cleaning up...
Command /usr/bin/python -c &quot;import setuptools, tokenize;__file__='/tmp/pip-build-Hqt4sF/lxml/setup.py';exec(compile(getattr(tokenize, 'open', open)(__file__).read().replace('\r\n', '\n'), __file__, 'exec'))&quot; install --record /tmp/pip-tUvZhB-record/install-record.txt --single-version-externally-managed --compile failed with error code 1 in /tmp/pip-build-Hqt4sF/lxml
Storing debug log for failure in /home/aaa/.pip/pip.log
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20200411085849604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMDkyMDc2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></figure>
<pre><code class="language-python">sudo apt-get install mysql-server mysql-client
#然后mysql -V查看mysql是否安装成功
sudo  apt-get install libmysqlclient-dev python3-dev
#然后
pip install mysqlclient就不会报错找不到'mysql_config'了
</code></pre>
<h4 id="4创建数据库时设定默认编码为utf8">4.创建数据库时设定默认编码为utf8:</h4>
<pre><code class="language-mysql"> create database db_name default charset utf8 collate utf8_general_ci;
</code></pre>
<h4 id="下载django时指定国内的下载源">下载Django时指定国内的下载源：</h4>
<pre><code class="language-python">pip install django==2.1.7 -i https://pypi.douban.com/simple
</code></pre>
<h4 id="5modulenotfounderror-no-module-named-import_export">5.ModuleNotFoundError: No module named 'import_export'</h4>
<p>安装这个库</p>
<pre><code class="language-python">pip install django-import-export
#不能简单的安装import_export
</code></pre>
<p>并且在settings.py中注册这个app</p>
<pre><code class="language-python">INSTALLED_APPS = [
	'import_export',
]
</code></pre>
<p>xadmin安装时需要注册的两个app</p>
<pre><code class="language-python">INSTALLED_APPS = [
	'xadmin',
    'crispy_forms',
]
</code></pre>
<h4 id="6在pip安装时指定源的方法">6.在pip安装时，指定源的方法：</h4>
<h5 id="国内常用源列表">国内常用源列表</h5>
<p>清华大学 https://pypi.tuna.tsinghua.edu.cn/simple<br>
中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple<br>
阿里云 http://mirrors.aliyun.com/pypi/simple<br>
中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple<br>
豆瓣 (douban) http://pypi.douban.com/simple<br>
1.安装时临时指定国内源</p>
<pre><code class="language-python">pip3 install sweetest  -i https://pypi.tuna.tsinghua.edu.cn/simple
如果提示 host 不被信任可以加上参数 –trusted-host
pip3 install sweetest  -i https://pypi.tuna.tsinghua.edu.cn/simple --trusted-host  pypi.tuna.tsinghua.edu.cn
</code></pre>
<h4 id="7django-settingspy中设置为中文">7.django settings.py中设置为中文</h4>
<pre><code class="language-python">LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True
USE_L10N = True
USE_TZ = True
</code></pre>
<h4 id="8xadmin中的设置">8.xadmin中的设置</h4>
<pre><code class="language-python">#导入xadmin
import xadmin
#从当前的app中导入模型，以及模型中的类
from .models import Book,Category,Article
#定义全局，site_title为左上角的标题，site_footer为中间最下方的@后的文字
class Globlesettings(object):
    site_title=&quot;后台管理页面&quot;
    site_footer=&quot;后台管理页面所有&quot;
    #左侧菜单栏是否可以重叠
    menu_style = &quot;accordion&quot;
#设置xadmin中的主体
class Basesettings(object):
	#enable_themes设置为true时，只显示主题图表与Bootstrap2一个主体
    enable_themes=True
    #use_bootswatch=True时，可以显示很多种主题
    use_bootswatch=True
class BookAdmin(object):
	#可以显示的列
    list_display=[&quot;id&quot;,&quot;name&quot;,&quot;author&quot;]
    #查找的设置
    search_fields=[&quot;id&quot;,&quot;name&quot;,&quot;author&quot;]
    #过滤器的设置
    list_filter=[&quot;id&quot;,&quot;name&quot;,&quot;author&quot;]
    #可以在当前页面编辑的列
    list_editable=[&quot;name&quot;,&quot;author&quot;]
    model_icon=&quot;fa fa-bath&quot;
</code></pre>
<h4 id="9models中的配置">9.models中的配置</h4>
<pre><code class="language-python">    class Meta:
        #模型的名字
        verbose_name=&quot;文章&quot;
        #复数时显示以前的名字，不添加s
        verbose_name_plural=verbose_name
    def __str__(self):
        return self.name
</code></pre>
<h4 id="10要使后台管理系统中在左侧的名字显示为中文名设置方法如下">10.要使后台管理系统中在左侧的名字显示为中文名，设置方法如下：</h4>
<pre><code class="language-python">#settings.py
INSTALLED_APPS = [
	'article.apps.ArticleConfig',
]
#article/apps.py
class ArticleConfig(AppConfig):
    name = 'article'
    verbose_name = &quot;文章模块&quot;
</code></pre>
<h4 id="11xadmin重定向页面">11.xadmin重定向页面：</h4>
<pre><code class="language-python">#adminx.py
class ChangeIntoAdmin(object):
    # 指向自定义的页面
    object_list_template = 'base111.html'
    # 重写方法，把要展示的数据更新到 context
    def get_context(self):
        context = CommAdminView.get_context(self)
        bill_message = Book.objects.all()
        context.update(
            {
                'title': '转入分析',
            }
        )
        return context
xadmin.site.register(Book, ChangeIntoAdmin)
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django学习笔记数据库（二）]]></title>
        <id>https://906571331.github.io/yx.github.io/post/django-xue-xi-bi-ji-shu-ju-ku-er/</id>
        <link href="https://906571331.github.io/yx.github.io/post/django-xue-xi-bi-ji-shu-ju-ku-er/">
        </link>
        <updated>2020-04-11T00:48:55.000Z</updated>
        <content type="html"><![CDATA[<h4 id="1外键增加数据操作">1.外键：增加数据操作</h4>
<pre><code class="language-python">#models.py
#函数，可以提高代码的利用率
def set_default():
	return Category.object.get(pk=2)
class Category(models.Model):
    name=models.CharField(max_length=100)
class Article(models.Model):
    title=models.CharField(max_length=100)
    content=models.TextField()
    category=models.ForeignKey(&quot;Category&quot;,on_delete=models.CASCADE,bull=True)
    
#设置默认值    
category=models.ForeignKey(&quot;Category&quot;,on_delete=models.SET_DEFAULT,default=Category.objects.get(pk=2))
category=models.ForeignKey(&quot;Category&quot;,on_delete=models.SET(Category.objects.get(pk=2)))
category=models.ForeignKey(&quot;Category&quot;,on_delete=models.SET(set_default))
#使用的是别的app的外键，    
forntuser=models.ForeignKey(&quot;app_name.frontname&quot;,on_delete=models.CASCADE)
#on_delete=donothing，完全依靠数据库级别的约束
</code></pre>
<pre><code class="language-python">#views.py
def indexxxx(request):
    category=Category(name=&quot;最新文章&quot;)
    category.save()
    article=Article(title=&quot;标题&quot;,content=&quot;这是内容&quot;)
    article.category=category
    article.save()
    return HttpResponse(&quot;success 添加文章和标签&quot;)
</code></pre>
<p>外键引用自己，可以用于盖楼式评论</p>
<pre><code class="language-python">class comment(models.Model):
    content=models.TextField()
    origin_comment=models.ForeignKey(&quot;self&quot;,on_delete=models.CASCADE)
    
#或者写成    origin_comment=models.ForeignKey(&quot;comment&quot;,on_delete=models.CASCADE)
#或者写成    origin_comment=models.ForeignKey(&quot;article.comment&quot;,on_delete=models.CASCADE)
</code></pre>
<h4 id="2外键删除数据操作">2.外键：删除数据操作</h4>
<pre><code class="language-python">#views.py,级联操作，category删除时，文章也删除
def delete_view(request):
    category=Category.objects.get(pk=8)
    category.delete()
    return HttpResponse(&quot;delete success&quot;)
</code></pre>
<h1 id="表关系笔记">表关系笔记：</h1>
<h2 id="一对多">一对多：</h2>
<ol>
<li>应用场景：比如文章和作者之间的关系。一个文章只能由一个作者编写，但是一个作者可以写多篇文章。文章和作者之间的关系就是典型的多对一的关系。</li>
<li>实现方式：一对多或者多对一，都是通过<code>ForeignKey</code>来实现的。还是以文章和作者的案例进行讲解。</li>
</ol>
<pre><code class="language-python">class User(models.Model):
    username = models.CharField(max_length=20)
    password = models.CharField(max_length=100)

class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    author = models.ForeignKey(&quot;User&quot;,on_delete=models.CASCADE)
</code></pre>
<p>那么以后在给<code>Article</code>对象指定<code>author</code>，就可以使用以下代码来完成：</p>
<pre><code class="language-python">article = Article(title='abc',content='123')
author = User(username='zhiliao',password='111111')
# 要先保存到数据库中
author.save()
article.author = author
article.save()
</code></pre>
<p>并且以后如果想要获取某个用户下所有的文章，可以通过<code>article_set</code>来实现。示例代码如下：</p>
<pre><code class="language-python">user = User.objects.first()
# 获取第一个用户写的所有文章
articles = user.article_set.all()
for article in articles:
    print(article)
</code></pre>
<p>获取一个标签下的所有文章</p>
<pre><code class="language-python">#获取一个标签的所有文章
category=Category.objects.first()
articles=category.article_set.all()
for article in articles:
    print(article)
</code></pre>
<p>并且如果想要将文章添加到某个分类中。可以使用一下的方式：</p>
<pre><code class="language-python">category = Category.objects.first()
article = Article(title='bbb',content='vvv')
article.author = FrontUser.objects.first()
article.save()
category.article_set.add(article,bulk=False)
category.save()
</code></pre>
<ul>
<li>使用<code>bulk=False</code>，那么Django会自动的保存article，而不需要在添加到category之前先保存article。</li>
<li>或者是另外一种解决方式是，在添加到<code>category.article_set</code>中之前，先将<code>article</code>保存到数据库中。但是如果<code>article.category</code>不能为空，那么就产生一种死循环了，article没有<code>category</code>不能保存，而将article添加到<code>cateogry.artile_set</code>中，又需要article之前是已经存储到数据库中的。</li>
<li>如果是上面的那种需求，建议使用<code>bulk=False</code>的解决方案。</li>
</ul>
<h2 id="一对一">一对一：</h2>
<ol>
<li>在Django中一对一是通过<code>models.OnetToOneField</code>来实现的。这个<code>OneToOneField</code>其实本质上就是一个外键，只不过这个外键有一个<code>唯一约束（unique key）</code>，来实现一对一。</li>
<li>以后如果想要反向引用，那么是通过引用的模型的名字转换为小写的形式进行访问。比如以下模型：<pre><code class="language-python">class FrontUser(models.Model):
    username = models.CharField(max_length=200)

class UserExtension(models.Model):
    school = models.CharField(max_length=100)
    user = models.OneToOneField(&quot;FrontUser&quot;,on_delete=models.CASCADE)

# 通过userextension来访问UserExtension对象
user = FrontUser.objects.first()
print(user.userextension)
</code></pre>
</li>
</ol>
<pre><code class="language-python">def one_to_one_view(request):
	user=FrontUser.objects.first()
	extension=UserExtension(schoole='zhiliao')
	extension.user=user
	extension.save()
	return HttpResponse(&quot;success&quot;)
</code></pre>
<pre><code>`UserExtension`的对象，可以通过`user`来访问到对应的user对象。并且`FrontUser`对象可以使用`userextension`来访问对应的`UserExtension`对象。
如果不想使用Django默认的引用属性名字。那么可以在`OneToOneField`中添加一个`related_name`参数。示例代码如下：
```python
class FrontUser(models.Model):
    username = models.CharField(max_length=200)

class UserExtension(models.Model):
    school = models.CharField(max_length=100)
    user = models.OneToOneField(&quot;FrontUser&quot;,on_delete=models.CASCADE,related_name='extension')

# 通过extension来访问到UserExtension对象
user = FrontUser.objects.first()
print(user.extension)
```
那么以后就`FrontUser`的对象就可以通过`extension`属性来访问到对应的`UserExtension`对象。
</code></pre>
<h2 id="多对多">多对多：</h2>
<ol>
<li>
<p>应用场景：比如文章和标签的关系。一篇文章可以有多个标签，一个标签可以被多个文章所引用。因此标签和文章的关系是典型的多对多的关系。</p>
</li>
<li>
<p>实现方式：<code>Django</code>为这种多对多的实现提供了专门的<code>Field</code>。叫做<code>ManyToManyField</code>。还是拿文章和标签为例进行讲解。示例代码如下：</p>
</li>
</ol>
<pre><code class="language-python">class Article(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    tags = models.ManyToManyField(&quot;Tag&quot;,related_name=&quot;articles&quot;)

class Tag(models.Model):
    name = models.CharField(max_length=50)
</code></pre>
<p>在数据库层面，实际上<code>Django</code>是为这种多对多的关系建立了一个中间表。这个中间表分别定义了两个外键，引用到<code>article</code>和<code>tag</code>两张表的主键。</p>
<h1 id="查询条件笔记">查询条件笔记：</h1>
<ol>
<li>
<p>exact：在底层会被翻译成<code>=</code>。</p>
</li>
<li>
<p>iexact：在底层会被翻译成<code>LIKE</code>。</p>
<ul>
<li>LIKE和=：大部分情况下都是等价的，只有少数情况下是不等价的。</li>
<li>exict和iexact：他们的区别其实就是LIKE和=的区别，因为exact会被翻译成=，而iexact会被翻译成LIKE。</li>
<li>因为<code>field__exact=xxx</code>其实等价于<code>filed=xxx</code>，因此我们直接使用<code>filed=xxx</code>就可以了，并且因为大部分情况<code>exact</code>和<code>iexact</code>又是等价的，因此我们以后直接使用<code>field=xxx</code>就可以了。</li>
</ul>
</li>
<li>
<p>QuerySet.query：<code>query</code>可以用来查看这个<code>ORM</code>查询语句最终被翻译成的<code>SQL</code>语句。但是<code>query</code>只能被用在<code>QuerySet</code>对象上，不能用在普通的<code>ORM模型</code>上。因此如果你的查询语句是通过<code>get</code>来获取数据的，那么就不能使用<code>query</code>，因为<code>get</code>返回的是满足条件的<code>ORM</code>模型，而不是<code>QuerySet</code>。如果你是通过<code>filter</code>等其他返回<code>QuerySet</code>的方法查询的，那么就可以使用<code>query</code>。</p>
</li>
<li>
<p>contains：使用大小写敏感的判断，某个字符串是否在指定的字段中。这个判断条件会使用大小敏感，因此在被翻译成<code>SQL</code>语句的时候，会使用<code>like binary</code>，而<code>like binary</code>就是使用大小写敏感的。</p>
</li>
<li>
<p>icontains：使用大小写不敏感的判断，某个字符串是否被包含在指定的字段中。这个查询语句在被翻译成<code>SQL</code>的时候，使用的是<code>like</code>，而<code>like</code>在<code>MySQL</code>层面就是不区分大小写的。</p>
</li>
<li>
<p>contains和icontains：在被翻译成<code>SQL</code>的时候使用的是<code>%hello%</code>，就是只要整个字符串中出现了<code>hello</code>都能过够被找到，而<code>iexact</code>没有百分号，那么意味着只有完全相等的时候才会被匹配到。</p>
</li>
<li>
<p>in：可以直接指定某个字段的是否在某个集合中。示例代码如下：</p>
<pre><code class="language-python">articles = Article.objects.filter(id__in=[1,2,3])
</code></pre>
<p>也可以通过其他的表的字段来判断是否在某个集合中。示例代码如下：</p>
<pre><code class="language-python">categories = Category.objects.filter(article__id__in=[1,2,3])
</code></pre>
<p>如果要判断相关联的表的字段，那么也是通过<code>__</code>来连接。并且在做关联查询的时候，不需要写<code>models_set</code>，直接使用<code>模型的名字的小写化</code>就可以了。比如通过分类去查找相应的文章，那么通过<code>article__id__in</code>就可以了，而不是写成<code>article_set__id__in</code>的形式。当然如果你不想使用默认的形式，可以在外键定义的时候传递<code>related_query_name</code>来指定反向查询的名字。示例代码如下：</p>
<pre><code class="language-python">class Category(models.Model):
    name = models.CharField(max_length=100)

    class Meta:
        db_table = 'category'


class Article(models.Model):
    title = models.CharField(max_length=200)
    content = models.TextField()
    cateogry = models.ForeignKey(&quot;Category&quot;,on_delete=models.CASCADE,null=True,related_query_name='articles')

    class Meta:
        db_table = 'article'
</code></pre>
<p>因为在<code>cateogry</code>的<code>ForeignKey</code>中指定了<code>related_query_name</code>为<code>articles</code>，因此你不能再使用<code>article</code>来进行反向查询了。这时候就需要通过<code>articles__id__in</code>来进行反向查询。</p>
<p>反向查询是将模型名字小写化。比如<code>article__in</code>。可以通过<code>related_query_name</code>来指定自己的方式，而不使用默认的方式。<br>
反向引用是将模型名字小写化，然后再加上<code>_set</code>，比如<code>article_set</code>，可以通过<code>related_name</code>来指定自己的方式，而不是用默认的方式。</p>
<p>并且，如果在做反向查询的时候，如果查询的字段就是模型的主键，那么可以省略掉这个字段，直接写成<code>article__in</code>就可以了，不需要这个<code>id</code>了。</p>
<p><code>in</code>不仅仅可以指定列表/元组，还可以为<code>QuerySet</code>。比如要查询“文章标题中包含有hello的所有分类”，那么可以通过以下代码来实现：</p>
<pre><code class="language-python">articles = Article.objects.filter(title__icontains='hello')
categories = Category.objects.filter(articles__in=articles)
for cateogry in categories:
    print(cateogry)
</code></pre>
</li>
<li>
<p>gt、gte、lt、lte：代表的是大于、大于等于、小于、小于等于的条件。示例代码如下：</p>
<pre><code class="language-python">articles = Article.objects.filter(id__lte=3)
</code></pre>
</li>
<li>
<p>startswith、istartswith、endswith、iendswith：表示以某个值开始，不区分大小写的以某个值开始、以某个值结束、不区分大小写的以某个值结束。示例代码如下：</p>
<pre><code class="language-python">articles = Article.objects.filter(title__endswith=&quot;hello&quot;)
</code></pre>
</li>
<li>
<p>关于时间的查询条件：</p>
<ul>
<li>
<p>range：可以指定一个时间段。并且时间应该标记为<code>aware</code>时间，不然django会报警告。示例代码如下：</p>
<pre><code class="language-python">start_time = make_aware(datetime(year=2018,month=4,day=4,hour=17,minute=0,second=0))
end_time = make_aware(datetime(year=2018,month=4,day=4,hour=18,minute=0,second=0))
articles = Article.objects.filter(create_time__range=(start_time,end_time))
print(articles.query)
print(articles)
</code></pre>
</li>
<li>
<p>date：用年月日来进行过滤。如果想要使用这个过滤条件，那么前提必须要在<code>MySQL</code>中添加好那些时区文件。如何添加呢？参考教案。示例代码如下：</p>
<pre><code class="language-python">articles = Article.objects.filter(create_time__date=datetime(year=2018,month=4,day=4))
</code></pre>
</li>
<li>
<p>year/month/day：表示根据年/月/日进行查找。示例代码如下：</p>
<pre><code class="language-python">articles = Article.objects.filter(create_time__year__gte=2018)
</code></pre>
</li>
<li>
<p>week_day：根据星期来进行查找。1表示星期天，7表示星期六，2-6代表的是星期一到星期五。比如要查找星期三的所有文章，那么可以通过以下代码来实现：</p>
<pre><code class="language-python">articles = Article.objects.filter(create_time__week_day=4)
</code></pre>
</li>
<li>
<p>time：根据分时秒来进行查找。如果要具体到秒，一般比较难匹配到，可以使用区间的方式来进行查找。区间使用<code>range</code>条件。比如想要获取17时/10分/27-28秒之间的文章，那么可以通过以下代码来实现：</p>
<pre><code class="language-python">start_time = time(hour=17,minute=10,second=27)
end_time = time(hour=17,minute=10,second=28)
articles = Article.objects.filter(create_time__time__range=(start_time,end_time))
</code></pre>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[djang学习笔记数据库（一）]]></title>
        <id>https://906571331.github.io/yx.github.io/post/djang-xue-xi-bi-ji-shu-ju-ku-yi/</id>
        <link href="https://906571331.github.io/yx.github.io/post/djang-xue-xi-bi-ji-shu-ju-ku-yi/">
        </link>
        <updated>2020-04-08T07:52:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="本篇博客记录了博主在学习django操作数据库时的笔记">本篇博客记录了博主在学习Django操作数据库时的笔记：</h3>
<h4 id="1在有表单的页面viewspy的处理方式">1.在有表单的页面，views.py的处理方式:</h4>
<pre><code class="language-python">#在urls.py中有个url是name=index
#views.py
def add_book(request):
	if request.method=='GET':
		return render(request,&quot;add_book.html&quot;)
	else:
		name=request.POST.get('name')
		author=request.POST.get('author')
		return redirect(reverse('index'))
#url中传递多个值
/?P&lt;book_id&gt;\d+/
</code></pre>
<h4 id="2最简单的orm模型">2.最简单的ORM模型</h4>
<pre><code class="language-python">from djangfo.db import models
#创建一个模型，对应表中的的一张表
class Book(models.Model):
	#创建模型中的一个属性，对应表中的一个字段，id可有可无，AutoField是自动增长，可以设置为主键
	id=models.Autofield(primary_key=True)
	#当属性是CharField时，必须制定最大长度
	name=models.CharField(max_length=100,null=Flase)
	author=models.CharField(max_length=100)
	price = models.FloatField()
#一个模型的对象，对应数据库表中的一条数据
book =Book(name=&quot;三国演义&quot;，author=&quot;罗贯中&quot;，price=100)
book.save()
book.delete()
</code></pre>
<h4 id="3数据库迁移的两条命令">3.数据库迁移的两条命令</h4>
<pre><code class="language-bash">python manage.py makemigrations
python manage.py migrate
</code></pre>
<h4 id="4向数据库中插入数据">4.向数据库中插入数据</h4>
<pre><code class="language-python">#views.py
from .models import Book
from django.http import HttpResponse
def index(request):
    #使用ORM添加一条数据到数据库中
    book=Book(name=&quot;三国演义&quot;,author=&quot;罗贯中&quot;,price=100)
    book.save()
    return HttpResponse(&quot;图书添加成功&quot;)
</code></pre>
<pre><code class="language-python">#models.py
from django.db import models
#将普通的类映射为数据库中的ORM模型
#必须将父类设置为models.Model类，或其子类
class Book(models.Model):
    #AutoField代表是自动增长
    id=models.AutoField(primary_key=True)
    #设置CharField时必须设置最大长度，Null=False不能为空
    name=models.CharField(max_length=100,null=False)
    author=models.CharField(max_length=100,null=False)
    price=models.FloatField(null=False,default=0)
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200407091940656.png" alt="在这里插入图片描述" loading="lazy"><br>
<img src="https://img-blog.csdnimg.cn/2020040709195160.png" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="5查找数据一">5.查找数据（一）</h4>
<pre><code class="language-python">#views.py
from .models import Book
from django.http import HttpResponse
def index(request):
    #使用主键查找
    Book.objects.get(pk=1)
    return HttpResponse(&quot;图书查找成功&quot;)
</code></pre>
<pre><code class="language-python">#models.py
from django.db import models
#将普通的类映射为数据库中的ORM模型
#必须将父类设置为models.Model类，或其子类
class Book(models.Model):
    #AutoField代表是自动增长
    id=models.AutoField(primary_key=True)
    #设置CharField时必须设置最大长度，Null=False不能为空
    name=models.CharField(max_length=100,null=False)
    author=models.CharField(max_length=100,null=False)
    price=models.FloatField(null=False,default=0)
</code></pre>
<h4 id="6查找数据二">6.查找数据（二）</h4>
<pre><code class="language-python">#models.py
from django.db import models
#将普通的类映射为数据库中的ORM模型
#必须将父类设置为models.Model类，或其子类
class Book(models.Model):
    #AutoField代表是自动增长
    id=models.AutoField(primary_key=True)
    #设置CharField时必须设置最大长度，Null=False不能为空
    name=models.CharField(max_length=100,null=False)
    author=models.CharField(max_length=100,null=False)
    price=models.FloatField(null=False,default=0)
    #将以这种形式返回
    def __str__(self):
        return &quot;&lt;Book:({name},{author},{price})&gt;&quot;.format(name=self.name,author=self.author,price=self.price)
</code></pre>
<pre><code class="language-python">#views.py
from .models import Book
from django.http import HttpResponse
def index(request):
    #使用ORM添加一条数据到数据库中
    # book=Book(name=&quot;三国演义&quot;,author=&quot;罗贯中&quot;,price=100)
    # book.save()
    book=Book.objects.get(pk=1)
    print(book)
    return HttpResponse(book)
</code></pre>
<h4 id="7过滤查找">7.过滤查找</h4>
<pre><code class="language-python">#views.py
#.first返回第一条
def index(request):
    #使用ORM添加一条数据到数据库中
    # book=Book(name=&quot;三国演义&quot;,author=&quot;罗贯中&quot;,price=100)
    # book.save()
    # book=Book.objects.get(pk=1)
    # print(book)
    books=Book.objects.filter(name=&quot;三国演义&quot;).first()
    print(books)
    return HttpResponse(&quot;查找成功&quot;)
</code></pre>
<p>第一条为不加first，第二条为加.first<br>
<img src="https://img-blog.csdnimg.cn/20200407093859633.png" alt="在这里插入图片描述" loading="lazy"></p>
<h4 id="8删除数据">8.删除数据</h4>
<pre><code class="language-python">def index(request):    
	book=Book.objects.get(pk=1)
    book.delete()
    return HttpResponse(&quot;删除成功&quot;)
</code></pre>
<h4 id="9修改数据">9.修改数据</h4>
<pre><code class="language-python">def index(request):    
	book=Book.objects.get(pk=1)
	book.price=90
    book.save()
    return HttpResponse(&quot;修改成功&quot;)
</code></pre>
<h4 id="10field详解">10.field详解</h4>
<pre><code class="language-python">#必须设置primary_key，否则为一个普通的字段
id=models.BigAutoField(primary_key=true)
#如果删除则不显示
removed=models.NullBooleanField()
同时在views.py中如下设置
article=Article(removed=False)
article.save()
</code></pre>
<h4 id="python中的时区转换">python中的时区转换</h4>
<p>pytz库是专门用来处理时区的库</p>
<pre><code class="language-python">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; now=datetime.now()
&gt;&gt;&gt; now
datetime.datetime(2020, 4, 7, 2, 27, 35, 710567)
&gt;&gt;&gt; import patz
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ModuleNotFoundError: No module named 'patz'
&gt;&gt;&gt; import pytz
&gt;&gt;&gt; utc_timezone=pytz.timezone('UTC')
&gt;&gt;&gt; now.astimezone(utc_timezone)
datetime.datetime(2020, 4, 7, 9, 27, 35, 710567, tzinfo=&lt;UTC&gt;)
&gt;&gt;&gt; now
datetime.datetime(2020, 4, 7, 2, 27, 35, 710567)

</code></pre>
<h1 id="常用field笔记">常用Field笔记：</h1>
<h2 id="navie时间和aware时间">navie时间和aware时间：</h2>
<h3 id="什么是navie时间什么是aware时间">什么是navie时间？什么是aware时间？</h3>
<ol>
<li>navie时间：不知道自己的时间表示的是哪个时区的。也就是不知道自己几斤几两。比较幼稚。</li>
<li>aware时间：知道自己的时间表示的是哪个时区的。也就是比较清醒。</li>
</ol>
<h3 id="pytz库">pytz库：</h3>
<p>专门用来处理时区的库。这个库会经常更新一些时区的数据，不需要我们担心。并且这个库在安装Django的时候会默认的安装。如果没有安装，那么可以通过<code>pip install pytz</code>的方式进行安装。</p>
<h3 id="astimezone方法">astimezone方法：</h3>
<p>将一个时区的时间转换为另外一个时区的时间。这个方法只能被<code>aware</code>类型的时间调用。不能被<code>navie</code>类型的时间调用。<br>
示例代码如下：</p>
<pre><code class="language-python">import pytz
from datetime import datetime
now = datetime.now() # 这是一个navie类型的时间
utc_timezone = pytz.timezone(&quot;UTC&quot;) # 定义UTC的时区对象
utc_now = now.astimezone(utc_timezone) # 将当前的时间转换为UTC时区的时间
&gt;&gt; ValueError: astimezone() cannot be applied to a naive datetime # 会抛出一个异常，原因就是因为navie类型的时间不能调用astimezone方法


now = now.replace(tzinfo=pytz.timezone('Asia/Shanghai'))
utc_now = now.astimezone(utc_timezone)
# 这时候就可以正确的转换。
</code></pre>
<h3 id="replace方法">replace方法：</h3>
<p>可以将一个时间的某些属性进行更改。</p>
<h3 id="djangoutilstimezonenow方法">django.utils.timezone.now方法：</h3>
<p>会根据<code>settings.py</code>中是否设置了<code>USE_TZ=True</code>获取当前的时间。如果设置了，那么就获取一个<code>aware</code>类型的<code>UTC</code>时间。如果没有设置，那么就会获取一个<code>navie</code>类型的时间。</p>
<pre><code class="language-python">#models.py
create_time=models.DateTimeField(default=timezone.now())
#views.py
book=Book(create_time=now())
book.save()
</code></pre>
<p>和本地时间差8个小时<br>
<img src="https://img-blog.csdnimg.cn/20200407180926600.png" alt="在这里插入图片描述" loading="lazy"><br>
在本地显示时间时：<br>
<img src="https://img-blog.csdnimg.cn/20200407182550898.png" alt="在这里插入图片描述" loading="lazy"></p>
<pre><code class="language-python">#models.py
create_time=models.DateTimeField(default=timezone.now())
#auto_now_add第一次保存进数据库时
create_time=models.DateTimeField(auto_now_add=True)
</code></pre>
<pre><code class="language-python"> #views.py
def index()request:
     book=Book.objects.get(pk=3)
     create_time=book.create_time
     return render(request,&quot;inde.html&quot;,context={'create_time':create_time})
</code></pre>
<pre><code class="language-html">#在头部引入
{% load tz %}
#在合适的地方，不加localtime也可以正确显示
{{ create_time|localtime }}
</code></pre>
<h3 id="djangoutilstimezonelocaltime方法">django.utils.timezone.localtime方法：</h3>
<p>会根据<code>setting.py</code>中的<code>TIME_ZONE</code>来将一个<code>aware</code>类型的时间转换为<code>TIME_ZONE</code>指定时区的时间。</p>
<h2 id="datefield">DateField：</h2>
<p>日期类型。在<code>Python</code>中是<code>datetime.date</code>类型，可以记录年月日。在映射到数据库中也是<code>date</code>类型。使用这个<code>Field</code>可以传递以下几个参数：</p>
<ol>
<li><code>auto_now</code>：在每次这个数据保存的时候，都使用当前的时间。比如作为一个记录修改日期的字段，可以将这个属性设置为<code>True</code>。更新时间</li>
<li><code>auto_now_add</code>：在每次数据第一次被添加进去的时候，都使用当前的时间。比如作为一个记录第一次入库的字段，可以将这个属性设置为<code>True</code>。创建时间</li>
</ol>
<h2 id="datetimefield">DateTimeField：</h2>
<p>日期时间类型，类似于<code>DateField</code>。不仅仅可以存储日期，还可以存储时间。映射到数据库中是<code>datetime</code>类型。这个<code>Field</code>也可以使用<code>auto_now</code>和<code>auto_now_add</code>两个属性。</p>
<h2 id="timefield">TimeField：</h2>
<p>时间类型。在数据库中是<code>time</code>类型。在<code>Python</code>中是<code>datetime.time</code>类型。</p>
<h3 id="navie和aware介绍以及在django中的用法">navie和aware介绍以及在django中的用法：</h3>
<p>https://docs.djangoproject.com/en/2.0/topics/i18n/timezones/</p>
<h2 id="emailfield">EmailField：</h2>
<p>类似于<code>CharField</code>。在数据库底层也是一个<code>varchar</code>类型。最大长度是254个字符。</p>
<h2 id="filefield">FileField：</h2>
<p>用来存储文件的。这个请参考后面的文件上传章节部分。</p>
<h3 id="imagefield">ImageField：</h3>
<p>用来存储图片文件的。这个请参考后面的图片上传章节部分。</p>
<h3 id="floatfield">FloatField：</h3>
<p>浮点类型。映射到数据库中是<code>float</code>类型。</p>
<h3 id="integerfield">IntegerField：</h3>
<p>整形。值的区间是<code>-2147483648——2147483647</code>。</p>
<h3 id="bigintegerfield">BigIntegerField：</h3>
<p>大整形。值的区间是<code>-9223372036854775808——9223372036854775807</code>。</p>
<h3 id="positiveintegerfield">PositiveIntegerField：</h3>
<p>正整形。值的区间是<code>0——2147483647</code>。</p>
<h3 id="smallintegerfield">SmallIntegerField：</h3>
<p>小整形。值的区间是<code>-32768——32767</code>。</p>
<h3 id="positivesmallintegerfield">PositiveSmallIntegerField：</h3>
<p>正小整形。值的区间是<code>0——32767</code>。</p>
<h3 id="textfield">TextField：</h3>
<p>大量的文本类型。映射到数据库中是longtext类型。</p>
<h3 id="uuidfield">UUIDField：</h3>
<p>只能存储<code>uuid</code>格式的字符串。<code>uuid</code>是一个32位的全球唯一的字符串，一般用来作为主键。</p>
<h3 id="urlfield">URLField：</h3>
<p>类似于<code>CharField</code>，只不过只能用来存储<code>url</code>格式的字符串。并且默认的<code>max_length</code>是200。</p>
<h2 id="field常用的参数">Field常用的参数</h2>
<h3 id="null">null：</h3>
<p>如果设置为<code>True</code>，<code>Django</code>将会在映射表的时候指定是否为空。默认是为<code>False</code>。在使用字符串相关的<code>Field</code>（CharField/TextField）的时候，官方推荐尽量不要使用这个参数，也就是保持默认值<code>False</code>。因为<code>Django</code>在处理字符串相关的<code>Field</code>的时候，即使这个<code>Field</code>的<code>null=False</code>，如果你没有给这个<code>Field</code>传递任何值，那么<code>Django</code>也会使用一个空的字符串<code>&quot;&quot;</code>来作为默认值存储进去。因此如果再使用<code>null=True</code>，<code>Django</code>会产生两种空值的情形（NULL或者空字符串）。如果想要在表单验证的时候允许这个字符串为空，那么建议使用<code>blank=True</code>。如果你的<code>Field</code>是<code>BooleanField</code>，那么对应的可空的字段则为<code>NullBooleanField</code>。</p>
<h3 id="blank">blank：</h3>
<p>标识这个字段在表单验证的时候是否可以为空。默认是<code>False</code>。<br>
这个和<code>null</code>是有区别的，<code>null</code>是一个纯数据库级别的。而<code>blank</code>是<code>表单验证</code>级别的。</p>
<h3 id="db_column">db_column：</h3>
<p>这个字段在数据库中的名字。如果没有设置这个参数，那么将会使用模型中属性的名字。</p>
<h3 id="default">default：</h3>
<p>默认值。可以为一个值，或者是一个函数，但是不支持<code>lambda</code>表达式。并且不支持列表/字典/集合等可变的数据结构。</p>
<h3 id="primary_key">primary_key：</h3>
<p>是否为主键。默认是<code>False</code>。</p>
<h3 id="unique">unique：</h3>
<p>在表中这个字段的值是否唯一。一般是设置手机号码/邮箱等。</p>
<p>更多<code>Field</code>参数请参考官方文档：<a href="https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/">https://docs.djangoproject.com/zh-hans/2.0/ref/models/fields/</a></p>
<h2 id="模型中meta配置">模型中<code>Meta</code>配置：</h2>
<p>对于一些模型级别的配置。我们可以在模型中定义一个类，叫做<code>Meta</code>。然后在这个类中添加一些类属性来控制模型的作用。比如我们想要在数据库映射的时候使用自己指定的表名，而不是使用模型的名称。那么我们可以在<code>Meta</code>类中添加一个<code>db_table</code>的属性。示例代码如下：</p>
<pre><code class="language-python">class Book(models.Model):
    name = models.CharField(max_length=20,null=False)
    desc = models.CharField(max_length=100,name='description',db_column=&quot;description1&quot;)

class Meta:
    db_table = 'book_model'
</code></pre>
<p>以下将对<code>Meta</code>类中的一些常用配置进行解释。</p>
<h3 id="db_table">db_table：</h3>
<p>这个模型映射到数据库中的表名。如果没有指定这个参数，那么在映射的时候将会使用模型名来作为默认的表名。</p>
<h3 id="ordering">ordering：</h3>
<p>设置在提取数据的排序方式。后面章节会讲到如何查找数据。比如我想在查找数据的时候根据添加的时间排序，那么示例代码如下：</p>
<pre><code class="language-python">class Book(models.Model):
	name = models.CharField(max_length=20,null=False)
	desc = models.CharField(max_length=100,name='description',db_column=&quot;description1&quot;)
	pub_date = models.DateTimeField(auto_now_add=True)

	class Meta:
		db_table = 'book_model'
		#-号表示相反排序
		ordering = ['-pub_date']
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用JavaScript实时获取系统时间]]></title>
        <id>https://906571331.github.io/yx.github.io/post/shi-yong-javascript-shi-shi-huo-qu-xi-tong-shi-jian/</id>
        <link href="https://906571331.github.io/yx.github.io/post/shi-yong-javascript-shi-shi-huo-qu-xi-tong-shi-jian/">
        </link>
        <updated>2020-04-08T02:15:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="本案例实现了使用js代码实时获取系统时间">本案例实现了使用js代码实时获取系统时间</h3>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset=&quot;utf-8&quot;&gt;
		&lt;title&gt;实时获取系统时间&lt;/title&gt;
		&lt;script language=&quot;JavaScript&quot;&gt;
			function realSystime(clock){
				var now=new Date();//创建Date对象
				var year=now.getFullYear();//获取年份
				var month=now.getMonth();//获取月份
				var date=now.getDate();//获取日期
				var day=now.getDay();//获取星期
				var hour=now.getHours();//获取小时
				var minu=now.getMinutes();//获取分钟
				var sec=now.getSeconds();//获取秒
				month=month+1;
				var arr_week=new Array(&quot;星期日&quot;,&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;);
				var week=arr_week[day];//获取中文格式的星期，是个数组
				var time=year+&quot;年&quot;+month+&quot;月&quot;+date+&quot;日&quot; +week+&quot; &quot;+hour+&quot;:&quot;+minu+&quot;:&quot;+sec;//组合系统时间
				clock.innerHTML=&quot;当前时间：&quot;+time;//显示系统时间
			}
			window.onload=function(){
				window.setInterval(&quot;realSystime(clock)&quot;,1000);//实时获取并显示系统时间
			}
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id=&quot;clock&quot;&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
]]></content>
    </entry>
</feed>